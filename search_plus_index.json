{"./":{"url":"./","title":"Introduction","keywords":"","body":"IntroductionIntroduction Copyright© 浙ICP备19008730号 卓帆网 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-20 10:56:22 "},"java/SpringMVC启动过程详解.html":{"url":"java/SpringMVC启动过程详解.html","title":"SpringMVC启动过程详解.md","keywords":"","body":" SpringMVC启动过程详解（li） 　　通过对SpringMVC启动过程的深入研究，期望掌握Java Web容器启动过程；掌握SpringMVC启动过程；了解SpringMVC的配置文件如何配置，为什么要这样配置；掌握SpringMVC是如何工作的；掌握Spring源码的设计和增强阅读源码的技巧。 目录 1.Web容器初始化过程 2.SpringMVC中web.xml配置 3.认识ServletContextListener 4.认识ContextLoaderListener 5.DispatcherServlet初始化（HttpServletBean • FrameworkServlet • DispatcherServlet） 6.ContextLoaderListener与DispatcherServlet关系 7.DispatcherServlet的设计 8.DispatcherServlet工作原理   一、Web容器初始化过程 上图展示了web容器初始化的过程，其官方文档给出了这样的描述： 　　When a web application is deployed into a container, the following steps must be performed, in this order, before the web application begins processing client requests. Instantiate an instance of each event listener identified by a element in the deployment descriptor. For instantiated listener instances that implement ServletContextListener, call the contextInitialized() method. Instantiate an instance of each filter identified by a element in the deployment descriptor and call each filter instance's init() method. Instantiate an instance of each servlet identified by a element that includes a element in the order defined by the load-on-startup element values, and call each servlet instance's init() method. 二、SpringMVC中web.xml的配置 上图是截取的web.xml中的配置，在标签中定义了spring容器加载器；在标签中定义了spring前端控制器。 上图是源码中接口ServletContextListener的定义，可以看到在其注释中指明：servlet和Filter初始化前和销毁后，都会给实现了servletContextListener接口的监听器发出相应的通知。 上面是类ContextLoadListener的定义，它实现了上面的servletContextListener。这里用到了代理模式，简单的代理了ContextLoader类。ContextLoadListener类用来创建Spring application context，并且将application context注册到servletContext里面去。 结合上面的WEB容器启动的过程，以及接口ServletContextListener和类ContextLoadListener。我们知道： 　　在 Servlet API中有一个ServletContextListener接口，它能够监听ServletContext对象的生命周期，实际上就是监听Web应用的生命周期。当Servlet容器启动或终止Web应用时，会触发ServletContextEvent事件，该事件由ServletContextListener来处理。在ServletContextListener接口中定义了处理ServletContextEvent 事件的两个方法contextInitialized()和contextDestroyed()。 　　ContextLoaderListener监听器的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置了这个监听器，启动容器时，就会默认执行它实现的方法。由于在ContextLoaderListener中关联了ContextLoader这个类，所以整个加载配置过程由ContextLoader来完成。 上面是initWebApplicationContext的过程，方法名称即是其含义。方法中首先创建了WebApplicationContext，配置并且刷新实例化整个SpringApplicationContext中的Bean。因此，如果我们的Bean配置出错的话，在容器启动的时候，会抛异常出来的。 　　综上，ContextLoaderListener类起着至关重要的作用。它读取web.xml中配置的context-param中的配置文件，提前在web容器初始化前准备业务对应的Application context;将创建好的Application context放置于ServletContext中，为springMVC部分的初始化做好准备。 三、DispatchServlet初始化 　　在SpringMVC架构中，DispatchServlet负责请求分发，起到控制器的作用。下面详细来解释说明： DispatchServlet名如其义，它的本质上是一个Servlet。从上面图可以看到，下层的子类不断的对HttpServlet父类进行方法扩展。 上图是抽象类HttpServletBean的实现，我们知道HttpServlet有两大核心方法：init()和service()方法。HttpServletBean重写了init()方法，在这部分，我们可以看到其实现思路：公共的部分统一来实现，变化的部分统一来抽象，交给其子类来实现，故用了abstract class来修饰类名。此外，HttpServletBean提供了一个HttpServlet的抽象实现，使的Servlet不再关心init-param部分的赋值，让servlet更关注于自身Bean初始化的实现。 上图是FrameworkServlet的官方定义， 它提供了整合web javabean和spring application context的整合方案。那么它是如何实现的呢？在源码中我们可以看到通过执行initWebApplicationContext()方法和initFrameworkServlet()方法实现。 DispatchServlet是HTTP请求的中央调度处理器，它将web请求转发给controller层处理，它提供了敏捷的映射和异常处理机制。DispatchServlet转发请求的核心代码在doService()方法中实现，详细代码参照图上。 上图是DispatchServlet类和ContextLoaderListener类的关系图。首先，用ContextLoaderListener初始化上下文，接着使用DispatchServlet来初始化WebMVC的上下文。 上图是DispatchServlet的工作流程图，作为HTTP请求的中央控制器，它在SpringMVC中起着分发请求的作用。下面总结了DispatchServlet设计的一些特点总结。 四、请求流程   Copyright© 浙ICP备19008730号 卓帆网 2019 all right reserved，powered by Gitbook该文件修订时间： 2017-08-09 15:50:36 "},"java/hibernate.html":{"url":"java/hibernate.html","title":"Hibernate使用总结","keywords":"","body":"Hibernate使用总结 1、参数化查询建议使用命名参数方式如select a.* from user a where a.name=:name 2、设置参数：单个对象的时候直接query.setParameter(\"name\",value);当参数为集合的时候,query.setParameterList(\"name\",value); 3、当参数的中包含like的时候，%%的拼接应用到参数中，sql中直接一个名称参数代替 4、当返回的结果包含一个唯一值的时候，query.addScalar(\"count\"); query.uniqueResult().toString() 可以获得这个唯一值 5、当返回的结果映射成对象的时候query.addEntity(DocTemplate.class); 6、当返回的结果是Map的时候 query.setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP) 7、表中的默认字段被重置为null的时候，将jpa中的@Column(name = \"modifydate\",insertable =false,updatable = false)，这样插入和更新就不会包含这个字段 Copyright© 浙ICP备19008730号 卓帆网 2019 all right reserved，powered by Gitbook该文件修订时间： 2017-07-27 15:39:58 "},"java/idea debug技巧.html":{"url":"java/idea debug技巧.html","title":"ideat debug技巧","keywords":"","body":"ideat debug技巧 断点回退 错过了关键的断点或者想重新debug错过的信息，难道要重新开始？ A、 标识1，表示回退到调用栈的上一级。如现在执行到26行，点1图标，则回退到21行，再点1图标则继续回退到12行。注意，回退到方法调用处时，现场也会回退到调用前的状态（即下面的debugger和variables等窗口中的值会变成调用前）。 B、 2表示直接运行到光标处断点，适合于临时断点。 断点过滤 循环中debug难道一直单步下去？ 实例过滤 class过滤器 condition过滤器 其他 总结 1、drop frame 回退到方法调用处。在错过关键代码调试，需要重新调试时，可考虑回退，而不用再次发起请求。 2、断点过滤 适用集合迭代处理时，需要调试集合中某个对象的处理过程，可使用断点过滤。 3、属性值改变时调试 使用简单，只要在类的属性设置断点即可。 适用于返回某个值不正确时，可快速定位值改变的代码位置。 Copyright© 浙ICP备19008730号 卓帆网 2019 all right reserved，powered by Gitbook该文件修订时间： 2017-08-11 16:14:38 "},"java/idea快捷键.html":{"url":"java/idea快捷键.html","title":"IntelliJ IDEA使用技巧一览表","keywords":"","body":" Alt+1 快速打开或隐藏工程面板 ALT+7 靠左窗口显示当前文件的结构 http://idea.iteblog.com/key.php 在线激活 ctrl+shirt+enter 关闭标签 跳到行末 全屏 ctrl+shirt+F12 调试 F7 单步进入 F8单步步出 F9运行至下一个断点 ctrl+shift+B 可以查看一个类的subtype(s)。包括subclass(s) or implementation(s) 另外 ctrl+H 可以查看一个类继承关系，也能达到你要的效果 ctrl+N 打开指定的类 IntelliJ Idea 常用快捷键列表 Alt+回车 导入包,自动修正 Ctrl+N 查找类 Ctrl+Shift+N 查找文件 Ctrl+Alt+L 格式化代码 Ctrl+Alt+O 优化导入的类和包 Alt+Insert 生成代码(如get,set方法,构造函数等) Ctrl+E或者Alt+Shift+C 最近更改的代码 Ctrl+R 替换文本 Ctrl+F 查找文本 Ctrl+Shift+Space 自动补全代码 Ctrl+空格 代码提示 Ctrl+Alt+Space 类名或接口名提示 Ctrl+P 方法参数提示 Ctrl+Shift+Alt+N 查找类中的方法或变量 Alt+Shift+C 对比最近修改的代码 Shift+F6 重构-重命名 Ctrl+Shift+先上键 Ctrl+X 删除行 Ctrl+D 复制行 Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/.../ ） Ctrl+J 自动代码 Ctrl+E 最近打开的文件 Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档 Alt+F1 查找代码所在位置 Alt+1 快速打开或隐藏工程面板 Ctrl+Alt+ left/right 返回至上次浏览的位置 Alt+ left/right 切换代码视图 Alt+ Up/Down 在方法间快速移动定位 Ctrl+Shift+Up/Down 代码向上/下移动。 F2 或Shift+F2 高亮错误或警告快速定位 代码标签输入完成后，按Tab，生成代码。 选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。 Ctrl+W 选中代码，连续按会有其他效果 选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。 Ctrl+Up/Down 光标跳转到第一行或最后一行下 Ctrl+B 快速打开光标处的类或方法 最常用快捷键 1.Ctrl＋E，可以显示最近编辑的文件列表 2.Shift＋Click可以关闭文件 3.Ctrl＋[或]可以跳到大括号的开头结尾 4.Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方 5.Ctrl＋F12，可以显示当前文件的结构 6.Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择 7.Ctrl＋N，可以快速打开类 8.Ctrl＋Shift＋N，可以快速打开文件 9.Alt＋Q可以看到当前方法的声明 10.Ctrl＋W可以选择单词继而语句继而行继而函数 11.Alt＋F1可以将正在编辑的元素在各个面板中定位 12.Ctrl＋P，可以显示参数信息 13.Ctrl＋Shift＋Insert可以选择剪贴板内容并插入 14.Alt＋Insert可以生成构造器/Getter/Setter等 15.Ctrl＋Alt＋V 可以引入变量。例如把括号内的SQL赋成一个变量 16.Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch 17.Alt＋Up and Alt＋Down可在方法间快速移动 下面的不是很有用 18.在一些地方按Alt＋Enter可以得到一些Intention Action，例如将”==”改为”equals()” 19.Ctrl＋Shift＋Alt＋N可以快速打开符号 20.Ctrl＋Shift＋Space在很多时候都能够给出Smart提示 21.Alt＋F3可以快速寻找 22.Ctrl＋/和Ctrl＋Shift＋/可以注释代码 23.Ctrl＋Alt＋B可以跳转到抽象方法的实现 24.Ctrl＋O可以选择父类的方法进行重写 25.Ctrl＋Q可以看JavaDoc 26.Ctrl＋Alt＋Space是类名自动完成 27.快速打开类/文件/符号时，可以使用通配符，也可以使用缩写 28.Live Templates! Ctrl＋J 29.Ctrl＋Shift＋F7可以高亮当前元素在当前文件中的使用 30.Ctrl＋Alt＋Up /Ctrl＋Alt＋Down可以快速跳转搜索结果 31.Ctrl＋Shift＋J可以整合两行 32.Alt＋F8是计算变量值 IntelliJ IDEA使用技巧一览表 在使用 InelliJ IDEA 的过程中，通过查找资料以及一些自己的摸索，发现这个众多 Java 程序员喜欢的 IDE 里有许多值得一提的小窍门，如果能熟练的将它们应用于实际开发过程中，相信它会大大节省你的开发时间，而且随之而来的还会有那么一点点成就感：） Try it ！ 1 、写代码时用 Alt-Insert （ Code|Generate… ）可以创建类里面任何字段的 getter 与 setter 方法。 2 、右键点击断点标记（在文本的左边栏里）激活速查菜单，你可以快速设置 enable/disable 断点或者条件它的属性。 3 、 CodeCompletion （代码完成）属性里的一个特殊的变量是，激活 Ctrl-Alt-Space 可以完成在或不在当前文件里的类名。如果类没有引入则 import 标志会自动创建。 4 、使用 Ctrl-Shift-V 快捷键可以将最近使用的剪贴板内容选择插入到文本。使用时系统会弹出一个含有剪贴内容的对话框，从中你可以选择你要粘贴的部分。 5 、利用 CodeCompletion （代码完成）属性可以快速地在代码中完成各种不同地语句，方法是先键入一个类名地前几个字母然后再用 Ctrl-Space 完成全称。如果有多个选项，它们会列在速查列表里。 6 、用 Ctrl-/ 与 Ctrl-Shift-/ 来注释 / 反注释代码行与代码块。 -/ 用单行注释标记（“ //… ”）来注释 / 反注释当前行或者选择地代码块。而 Ctrl-Shift-/ 则可以用块注释标记（“ /…/ ”）把所选块包围起来。要反注释一个代码块就在块中任何一个地方按 Ctrl-Shift-/ 即可。 7 、按 Alt-Q （ View|Context Info ）可以不需要移动代码就能查看当前方法地声明。连续按两次会显示当前所编辑的类名。 8 、使用 Refactor|Copy Class… 可以创建一个所选择的类的“副本”。这一点很有用，比如，在你想要创建一个大部分内容都和已存在类相同的类时。 9 、在编辑器里 Ctrl-D 可以复制选择的块或者没有所选块是的当前行。 10 、 Ctrl-W （选择字）在编辑器里的功能是先选择脱字符处的单词，然后选择源代码的扩展区域。举例来说，先选择一个方法名，然后是调用这个方法的表达式，然后是整个语句，然后包容块，等等。 11 、如果你不想让指示事件细节的“亮球”图标在编辑器上显示，通过按 Alt-Enter 组合键打开所有事件列表然后用鼠标点击它就可以把这个事件文本附件的亮球置成非活动状态。 这样以后就不会有指示特殊事件的亮球出现了，但是你仍然可以用 Alt-Enter 快捷键使用它。 12 、在使用 CodeCompletion 时，可以用逗点（ . ）字符，逗号（，）分号（；），空格和其它字符输入弹出列表里的当前高亮部分。选择的名字会随着输入的字符自动输入到编辑器里。 13 、在任何工具窗口里使用 Escape 键都可以把焦点移到编辑器上。 Shift-Escape 不仅可以把焦点移到编辑器上而且还可以隐藏当前（或最后活动的）工具窗口。 F12 键把焦点从编辑器移到最近使用的工具窗口。 14 、在调试程序时查看任何表达式值的一个容易的方法就是在编辑器中选择文本（可以按几次 Ctrl-W 组合键更有效地执行这个操作）然后按 Alt-F8 。 15 、要打开编辑器脱字符处使用的类或者方法 Java 文档的浏览器，就按 Shift-F1 （右键菜单的 External JavaDoc ）。 要使用这个功能须要把加入浏览器的路径，在“ General ”选项中设置（ Options | IDE Settings ），另外还要把创建的 Java 文档加入到工程中（ File | Project Properties ）。 16 、用 Ctrl-F12 （ View | File Structure Popup ）键你可以在当前编辑的文件中快速导航。 这时它会显示当前类的成员列表。选中一个要导航的元素然后按 Enter 键或 F4 键。要轻松地定位到列表中的一个条目，只需键入它的名字即可。 17 、在代码中把光标置于标记符或者它的检查点上再按 Alt-F7 （右键菜单中的 Find Usages… ）会很快地查找到在整个工程中使用地某一个类、方法或者变量的位置。 18 、按 Ctrl-N （ Go to | Class… ）再键入类的名字可以快速地在编辑器里打开任何一个类。从显示出来的下拉列表里选择类。 同样的方法你可以通过使用 Ctrl-Shift-N （ Go to | File… ）打开工程中的非 Java 文件。 19 、要导航代码中一些地方使用到的类、方法或者变量的声明，把光标放在查看项上再按 Ctrl-B 即可。也可以通过按 Ctrl 键的同时在查看点上单击鼠标键调转到声明处。 20 、把光标放到查看点上再按 Ctrl-Alt-B 可以导航到一个抽象方法的实现代码。 21 、要看一个所选择的类的继承层次，按 Ctrl-H （ Browse Type Hierarchy ）即可。也可以激活编辑器中的继承关系视图查看当前编辑类的继承关系。22 、使用 Ctrl-Shift-F7 （ Search | Highlight Usages in File ）可以快速高亮显示当前文件中某一变量的使用地方。按 Escape 清除高亮显示。 23 、用 Alt-F3 （ Search | Incremental Search ）在编辑器中实现快速查查找功能。 在“ Search for: ”提示工具里输入字符，使用箭头键朝前和朝后搜索。按 Escape 退出。 24 、按 Ctrl-J 组合键来执行一些你记不起来的 Live Template 缩写。比如，键“ it ”然后按 Ctrl-J 看看有什么发生。 25 、 Introduce Variable 整合帮助你简化代码中复杂的声明。举个例子，在下面的代码片断里，在代码中选择一个表达式：然后按 Ctrl-Alt-V 。 26 、 Ctrl-Shift-J 快捷键把两行合成一行并把不必要的空格去掉以匹配你的代码格式。 27 、 Ctrl-Shift-Backspace （ Go to | Last Edit Location ）让你调转到代码中所做改变的最后一个地方。 多按几次 Ctrl-Shift-Backspace 查看更深的修改历史。 28 、用 Tools | Reformat Code… 根据你的代码样式参考（查看 Options | IDE Setting | Code Style ）格式化代码。 使用 Tools | Optimize Imports… 可以根据设置（查看 Options | IDE Setting | Code Style | Imports ）自动“优化” imports （清除无用的 imports 等）。 29 、使用 IDEA 的 Live Templates | Live Templates 让你在眨眼间创建许多典型代码。比如，在一个方法里键入。再按 Tab 键看有什么事情发生了。 用 Tab 键在不同的模板域内移动。查看 Options | Live Templates 获取更多的细节。 30 、要查看一个文件中修改的本地历史，激活右键菜单里的 Local VCS | Show History… 。也许你可以导航不同的文件版本，看看它们的不同之处再回滚到以前的任何一个版本吧。 使用同样的右键菜单条目还可以看到一个目录里修改的历史。有了这个特性你就不会丢失任何代码了。 31 、如果要了解主菜单里每一个条目的用途，把鼠标指针移到菜单条目上再应用程序框架的底部的状态栏里就会显示它们的一些简短描述，也许会对你有帮助。 32 、要在编辑器里显示方法间的分隔线，打开 Options | IDE Settings | Editor ，选中“ Show method separators ”检查盒（ checkbox ）。 33 、用 Alt-Up 和 Alt-Down 键可以在编辑器里不同的方法之间快速移动。 34 、用 F2/Shift-F2 键在高亮显示的语法错误间跳转。用 Ctrl-Alt-Down/Ctrl-Alt-Up 快捷键则可以在编译器错误信息或者查找操作结果间跳转。 35 、通过按 Ctrl-O （ Code | Override Methods… ）可以很容易地重载基本类地方法。要完成当前类 implements 的（或者抽象基本类的）接口的方法，就使用 Ctrl-I （ Code | Implement Methods… ）。 36 、如果光标置于一个方法调用的括号间，按 Ctrl-P 会显示一个可用参数的列表。 37 、要快速查看编辑器脱字符处使用的类或方法的 Java 文档，按 Ctrl-Q （在弹出菜单的 Show Quick JavaDoc 里）即可。 38 、像 Ctrl-Q （ Show Quick JavaDoc 显示简洁 Java 文档）， Ctrl-P （ Show Parameter Info 显示参数信息）， Ctrl-B （ Go to Declaration 跳转到声明）， Shift-F1 （ External JavaDoc 外部 Java 文档）以及其它一些快捷键不仅可以在编辑器里使用，也可以应用在代码完成右键列表里。 39 、 Ctrl-E （ View | Recent Files ）弹出最近访问的文件右键列表。选中文件按 Enter 键打开。 40 、在 IDEA 中可以很容易地对你的类，方法以及变量进行重命名并在所有使用到它们的地方自动更正。试一下，把编辑器脱字符置于任何一个变量名字上然后按 Shift-F6 （ Refactor | Rename… ）。在对话框里键入要显示地新名字再按 Enter 。你会浏览到使用这个变量地所有地方然后按“ Do Refactor ”按钮结束重命名操作。 41 、要在任何视图（ Project View 工程视图， Structure View 结构视图或者其它视图）里快速选择当前编辑地部分（类，文件，方法或者字段），按 Alt-F1 （ View | Select in… ）。 42 、在“ new ”字符后实例化一个已知类型对象时也许你会用到 SmartType 代码完成这个特性。比如，键入再按 Ctrl-Shift-Space ： 43 、通过使用 SmartType 代码完成，在 IDEA 中创建接口的整个匿名 implementation 也是非常容易的，比如，对于一些 listener （监听器），可以键入 Component component; component.addMouseListener( new ); 然后再按 Ctrl-Shift-Space 看看有什么发生了。 44 、在你需要设置一个已知类型的表达式的值时用 SmartType 代码完成也很有帮助。比如，键入 String s = ( 再按 Ctrl-Shift-Space 看看会有什么出现。 45 、在所有视图里都提供了速查功能：在树里只需键入字符就可以快速定位到一个条目。 46 、当你想用代码片断捕捉异常时，在编辑器里选中这个片断，按 Ctrl-Alt-T （ Code | Surround with… ）然后选择“ try/catch ”。它会自动产生代码片断中抛出的所有异常的捕捉块。在 Options | File Templates | Code tab 中你还可以自己定制产生捕捉块的模板。 用列表中的其它项可以包围别的一些结构。 47 、在使用代码完成时，用 Tab 键可以输入弹出列表里的高亮显示部分。 不像用 Enter 键接受输入，这个选中的名字会覆盖掉脱字符右边名字的其它部分。这一点在用一个方法或者变量名替换另一个时特别有用。 48 、在声明一个变量时代码完成特性会给你显示一个建议名。比如，开始键入“ private FileOutputStream ”然后按 Ctrl-Space 在 Options | IDE Setting | Code Style 中还可以为本地变量，参数，实例及静态字段定制名字。 Copyright© 浙ICP备19008730号 卓帆网 2019 all right reserved，powered by Gitbook该文件修订时间： 2017-08-11 16:18:47 "},"java/javamelody监控.html":{"url":"java/javamelody监控.html","title":"引入maven依赖","keywords":"","body":"引入maven依赖 net.bull.javamelody javamelody-core 1.70.0 配置web.xml 初始化启动参数增加monitoring-spring.xml javamelody net.bull.javamelody.MonitoringFilter true javamelody /monitoring REQUEST ASYNC javamelody /rest/* REQUEST ASYNC net.bull.javamelody.SessionListener 监控的地址 http://ip:port/serverName/monitoring 更多的参考 https://github.com/javamelody/javamelody/wiki 问题总结 1、c3p0数据源怎么监控 Copyright© 浙ICP备19008730号 卓帆网 2019 all right reserved，powered by Gitbook该文件修订时间： 2018-03-22 16:04:08 "},"java/java中的int与byte的转化.html":{"url":"java/java中的int与byte的转化.html","title":"java中的int与byte的转化","keywords":"","body":"java中的int与byte的转化 1、基础准备 1.1、原码 就是二进制码，最高位为符号位，0表示正数，1表示负数，剩余部分表示真值 1.2、反码 在原码的基础上，正数反码就是他本身，负数除符号位之外全部按位取反 1.3、补码 正数的补码就是自己本身， 负数的补码是在自身反码的基础上加1 2、对应到java操作 &（与）, | （或）, ^ （异或），~ （按位取反） & :当2个都为1的时候为1， 其他都是0 。 1&1 = 1， 1&0 = 0， 0&0 = 0； 他的作用是清0 | : 当2个只要有一个为1，就是1. 1|0 = 1; 0|0 = 0, 1|1 = 1; ^: 相同为0， 不相同为1， 1^0 = 1, 1^1 = 0, 0^0 = 0; 他的作用是定位翻转。 ~: 按位取反，0变为1， 1变为0； 举例说明 之所以要明确原码，反码，补码，是因为java中变量都是以补码的形式保存的。 比如 整行30 他的原码是：0001 1110. 正数，所以反码，补码都是0001 1110. 对于负数：-7 ，他的原码是 1000 0111， 第一位1表示是此数是负数。他的反码是：1111 1000, 补码在反码的基础上加1， 所以它的补码是1111 1001， 所以他的二进制数就是1111 1001 java为什么采用补码 如果用源码，那么0000 0000 和1000 0000 貌似都0， +0 ， 和- 0. 所以这造成了问题 cpu计算器只有加法没有减法， 减法需要用正数和负数相加得到** 3、oxff截取操作 oxff 16进制的255，2进制的11111111，&oxff后的作用我认为是，得到低8位 比如：src[0] = (byte) ((value>>8) & 0xFF) 4、int转byte /** * int到byte[] 由高位到低位 * @param i 需要转换为byte数组的整行值。 * @return byte数组 */ public static byte[] intToByteArray(int i) { byte[] result = new byte[4]; result[0] = (byte)((i >> 24) & 0xFF); result[1] = (byte)((i >> 16) & 0xFF); result[2] = (byte)((i >> 8) & 0xFF); result[3] = (byte)(i & 0xFF); return result; } /** * byte[]转int * @param bytes 需要转换成int的数组 * @return int值 */ public static int byteArrayToInt(byte[] bytes) { int value=0; for(int i = 0; i 5、后续 更多精彩，敬请关注， 程序员导航网 https://chenzhuofan.top Copyright© 浙ICP备19008730号 卓帆网 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-26 13:39:48 "},"java/java知识点.html":{"url":"java/java知识点.html","title":"1.使用maven构建多模块工程","keywords":"","body":"1.使用maven构建多模块工程 第一步:mvn archetype:generate -DgroupId=com.ttyl -DartifactId=ttyl_parent -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false -DarchetypeCatalog=local -X *注意 mvn archetype:create 已经不可用 第二步:将src文件夹删除，然后修改pom.xml文件，将jar修改为pom，pom表示它是一个被继承的模块 第三步:mvn archetype:generate -DgroupId=com.ttyl -DartifactId=ttyl_utils -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false -DarchetypeCatalog=local -X 第四步: 执行mvn idea:idea 将项目转化成idea项目 第五步:用idea打开项目 解决生成慢的问题: 可以看到，程序停在了下面这一行。 [DEBUG] Searching for remote catalog: http://repo1.maven.org/maven2/archetype-catalog.xml 去查询这个文件的时候网络比较差或者其他原因，导致挂在那里。 解决方法很简单 把上述地址复制到浏览器中，下载这个文件到本地。 把文件archetype-catalog.xml复制到目录.m2\\repository\\org\\apache\\maven\\archetype\\archetype-catalog\\2.2下面。 在上述命令后增加参数-DarchetypeCatalog=local，变成读取本地文件即可。 2、查看jar的编译jdk版本号 1、解压jar,在其中一个class文件下启动命令行输入 在jar包中，用winrar解压一个类文件，然后在命令行下面输入 javap -verbose classname 会输出一些信息，大致如下: Compiled from \"HtmlCrawer.java\" public class org.eagleeye.html.HtmlCrawer extends java.lang.Object SourceFile: \"HtmlCrawer.java\" minor version: 0 major version: 50 Constant pool: const #1 = class #2; // org/eagleeye/html/HtmlCrawer const #2 = Asciz org/eagleeye/html/HtmlCrawer; const #3 = class #4; // java.lang/Object const #4 = Asciz java.lang/Object; const #5 = Asciz client; .... 后面省略了，可以看到前面有两行: minor version: 0 major version: 50 表示了类文件的版本 2、参考jdk的版本号对照表 3、关于jsp在火狐下的显示不正常 Html显示正常但是相同的jsp在chrome下正常而在firefox下不正常的原因: 替换掉jsp里面默认生成的\">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">替换掉jsp里面默认生成的。替换之后 发现问题解决了 3、安装jar到本地仓库 执行本地cmd命令 mvn install:install-file -Dfile=D:\\kaptcha-2.3.2.jar -DgroupId=com.google.code.kaptcha -DartifactId=kaptcha -Dversion=2.3.2 -Dpackaging=jar Copyright© 浙ICP备19008730号 卓帆网 2019 all right reserved，powered by Gitbook该文件修订时间： 2017-07-27 14:27:55 "},"java/springboot中实现多数据源.html":{"url":"java/springboot中实现多数据源.html","title":"springboot中实现多数据源","keywords":"","body":"springboot中实现多数据源 1、什么场景需要多数据源 业务读写分离 业务分库 业务功能模块拆分多库 2、常见的多数据源的方案 按照数据源分别把mapper和entity放到不同的package下，然后用两个数据源分别注册、扫描对应的package,独立的sessionfactoty 基于aop动态的切换的数据源 3、本文重点介绍的是基于aop的方案 3.1、原理介绍 DatabaseType列出所有的数据源的key---key DatabaseContextHolder是一个线程安全的DatabaseType容器，并提供了向其中设置和获取DatabaseType的方法 DynamicDataSource继承AbstractRoutingDataSource并重写其中的方法determineCurrentLookupKey()，在该方法中使用DatabaseContextHolder获取当前线程的DatabaseType MyBatisConfig中生成2个数据源DataSource的bean---value MyBatisConfig中将1）和4）组成的key-value对写入到DynamicDataSource动态数据源的targetDataSources属性（当然，同时也会设置2个数据源其中的一个为DynamicDataSource的defaultTargetDataSource属性中） 将DynamicDataSource作为primary数据源注入到SqlSessionFactory的dataSource属性中去，并且该dataSource作为transactionManager的入参来构造DataSourceTransactionManager 使用的时候，在dao层或service层先使用DatabaseContextHolder设置将要使用的数据源key，然后再调用mapper层进行相应的操作，建议放在dao层去做（当然也可以使用spring aop+自定注解去做） 注意：在mapper层进行操作的时候，会先调用determineCurrentLookupKey()方法获取一个数据源（获取数据源：先根据设置去targetDataSources中去找，若没有，则选择defaultTargetDataSource），之后在进行数据库操作。 3.2、代码示例 a、配置文件 spring.aop.proxy-target-class = true spring.aop.auto = true spring.datasource.druid.db1.url = spring.datasource.druid.db1.username = spring.datasource.druid.db1.password = spring.datasource.druid.db1.driver-class-name = com.mysql.jdbc.Driver spring.datasource.druid.db1.initialSize = 5 spring.datasource.druid.db1.minIdle = 5 spring.datasource.druid.db1.maxActive = 20 spring.datasource.druid.db2.url = spring.datasource.druid.db2.username = spring.datasource.druid.db2.password = spring.datasource.druid.db2.driver-class-name = com.mysql.jdbc.Driver spring.datasource.druid.db2.initialSize = 5 spring.datasource.druid.db2.minIdle = 5 spring.datasource.druid.db2.maxActive = 20 spring.datasource.druid.db3.url = spring.datasource.druid.db3.username = spring.datasource.druid.db3.password = spring.datasource.druid.db3.driver-class-name = com.mysql.jdbc.Driver spring.datasource.druid.db3.initialSize = 5 spring.datasource.druid.db3.minIdle = 5 spring.datasource.druid.db3.maxActive = 20 b、生成Datasource @Bean(name = \"db1\") @ConfigurationProperties(prefix = \"spring.datasource.druid.db1\") public DataSource db1() { return DruidDataSourceBuilder.create().build(); } @Bean(name = \"db2\") @ConfigurationProperties(prefix = \"spring.datasource.druid.db2\") public DataSource db2() { return DruidDataSourceBuilder.create().build(); } @Bean(name = \"db3\") @ConfigurationProperties(prefix = \"spring.datasource.druid.db3\") public DataSource db3() { return DruidDataSourceBuilder.create().build(); } c、定义数据源的key @Getter @AllArgsConstructor public enum DBTypeEnum { db1(\"db1\"), db2(\"db2\"), db3(\"db3\"); private String value; } d、构造数据源和sessionFactory /** * 动态数据源配置 * * @return */ @Bean @Primary public DataSource multipleDataSource( @Qualifier(\"db1\") DataSource db1, @Qualifier(\"db2\") DataSource db2, @Qualifier(\"db3\") DataSource db3) { DynamicDataSource dynamicDataSource = new DynamicDataSource(); Map targetDataSources = new HashMap<>(); targetDataSources.put(DBTypeEnum.db1.getValue(), db1); targetDataSources.put(DBTypeEnum.db2.getValue(), db2); targetDataSources.put(DBTypeEnum.db3.getValue(), db3); dynamicDataSource.setTargetDataSources(targetDataSources); dynamicDataSource.setDefaultTargetDataSource(db2); return dynamicDataSource; } @Bean(\"sqlSessionFactory\") public SqlSessionFactory sqlSessionFactory() throws Exception { MybatisSqlSessionFactoryBean sqlSessionFactory = new MybatisSqlSessionFactoryBean(); sqlSessionFactory.setDataSource(multipleDataSource(db1(), db2(), db3())); MybatisConfiguration configuration = new MybatisConfiguration(); configuration.setJdbcTypeForNull(JdbcType.NULL); configuration.setMapUnderscoreToCamelCase(true); configuration.setCacheEnabled(false); sqlSessionFactory.setConfiguration(configuration); // PerformanceInterceptor(),OptimisticLockerInterceptor() // 添加分页功能 sqlSessionFactory.setPlugins(new Interceptor[] {paginationInterceptor()}); sqlSessionFactory.setGlobalConfig(globalConfiguration()); return sqlSessionFactory.getObject(); } e、重写datasource切换策略 public class DynamicDataSource extends AbstractRoutingDataSource { @Override protected Object determineCurrentLookupKey() { return DbContextHolder.getDbType(); } } f、保存数据源切换的上下文信息 public class DbContextHolder { private static final ThreadLocal contextHolder = new ThreadLocal<>(); /** * 设置数据源 * * @param dbTypeEnum */ public static void setDbType(DBTypeEnum dbTypeEnum) { contextHolder.set(dbTypeEnum.getValue()); } /** * 取得当前数据源 * * @return */ public static String getDbType() { return (String) contextHolder.get(); } /** 清除上下文数据 */ public static void clearDbType() { contextHolder.remove(); } } g、aop实现动态的数据源切换 @Component @Order(value = -100) @Slf4j @Aspect public class DataSourceSwitchAspect { @Pointcut(\"execution(* top.zhuofan.datafly.mapper.db1..*.*(..))\") private void db1Aspect() {} @Pointcut(\"execution(* top.zhuofan.datafly.mapper.db2..*.*(..))\") private void db2Aspect() {} @Pointcut(\"execution(* top.zhuofan.datafly.mapper.db3..*.*(..))\") private void db3Aspect() {} @Before(\"db1Aspect()\") public void db1() { log.debug(\"切换到db1 数据源...\"); DbContextHolder.setDbType(DBTypeEnum.db1); } @Before(\"db2Aspect()\") public void db2() { log.debug(\"切换到db2 数据源...\"); DbContextHolder.setDbType(DBTypeEnum.db2); } @Before(\"db3Aspect()\") public void db3() { log.debug(\"切换到db3 数据源...\"); DbContextHolder.setDbType(DBTypeEnum.db3); } } 4、后续 更多精彩，敬请关注， 程序员导航网 https://chenzhuofan.top Copyright© 浙ICP备19008730号 卓帆网 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-26 19:56:48 "},"java/如何实现跨浏览器共享cookies.html":{"url":"java/如何实现跨浏览器共享cookies.html","title":"如何实现跨浏览器共享cookies","keywords":"","body":"如何实现跨浏览器共享cookies 1、cookies说明 cookies是浏览器缓存与服务之间数据的一种手段，是浏览器的默认行为；不通的浏览器的cookies在硬盘的存储位置是不同的 cookies存在域名使用限制，有效期，是否前端js可以操作，读取等属性 2、场景说明 用户在浏览器A上操作,调用第三方，跳转到第三方App 在App上完整业务后根据回调地址就行跳转回原来的业务系统 app唤起的浏览器B,(非跳转前的浏览器A),因为app有自己唤起浏览器逻辑。当手机上存在多个浏览器存在此问题 浏览器B无之前的会话状态，后续操作失败，直接跳转到登录页面 3、解决方案 4、重点说明 核心的逻辑是跳转前吧会话缓存到服务端 跳转的时候携带会话缓存key 跳转后根据会话缓存key获取缓存内容，还原会话状态 5、后续 更多精彩，敬请关注， 程序员导航网 https://chenzhuofan.top Copyright© 浙ICP备19008730号 卓帆网 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-10 20:37:40 "},"java/如何解决http请求返回结果中文乱码.html":{"url":"java/如何解决http请求返回结果中文乱码.html","title":"如何解决http请求返回结果中文乱码","keywords":"","body":"如何解决http请求返回结果中文乱码 1、问题描述 http请求中，请求的结果集中包含中文，最终以乱码展示。 2、问题的本质 乱码的本质是服务端返回的字符集编码与客户端的编码方式不一致。 场景的如服务端返回 ISO-8859-1，而客户端的编码默认是UTF-8 3、解决办法 解决的办法就是让服务端返回的结果的编码与客户端的编码保持一致 最直接有效的方法是在request的header中增加一个项 Accept:application/json;charset=UTF-8 4、题外拓展 http中最常见的2个header的区别 Content-Type:application/json;charset=UTF-8 Accept:application/json;charset=UTF-8 Content-Type 用于描述本次请求的body的内容是json格式，且编码为UTF-8 Accept 用于描述客户端希望返回的结果以json来组织，且UTF-8 Content-Type 用于描述request,而Accept用于描述reponse 5、后续 更多精彩，敬请关注， [ 程序员导航网](https://chenzhuofan.top) [https://chenzhuofan.top](https://chenzhuofan.top) Copyright© 浙ICP备19008730号 卓帆网 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-26 13:20:03 "},"java/记一次内存泄露的处理过程.html":{"url":"java/记一次内存泄露的处理过程.html","title":"记一次内存泄露的排查过程","keywords":"","body":"记一次内存泄露的排查过程 1、现象分析 新产品上线后，流量导入过来，服务的内存持续升高，且有增无减。随着流量的升高，内存增加的速度也是线性增涨。 2、准备知识 2.1、java memory结构 2.1.1、分代概念 对于垃圾收集算法来说，分代回收是高级算法之一。对象按照生成时间进行分代，刚刚生成不久的年轻对象划为新生代（Young gen-eration），而存活了较长时间的对象划为老生代（Old generation）。根据具体实现方式的不同，可能还会划分更多的代。比如有的把永久代也算做一个代。 2.1.2、memory划分 java memory主要分heap memory 和 non-heap memory，其计算公式如下： ​ Max memory = [-Xmx] + [-XX:MaxPermSize] + number_of_threads * [-Xss] 2.1.3、heap结构 按分代，分young-eden,young-survivor,old 用-Xmn,-Xms,-Xmx来指定 2.1.4、non-heap结构 包括metaspace,thread stacks,compiled native code,memory allocated by native code -XX:PermSize或-XX:MetaspceSize,-Xss或-XX:ThreadStackSize 2.2 、PermGen与Metaspace 2.2.1、字符串常量池的变化 在java7的时候将字符串常量池则移到java heap 所有的被intern的String被存储在PermGen区.PermGen区使用-XX:MaxPermSize=N来设置最大大小，但是由于应用程序string.intern通常是不可预测和不可控的，因此不好设置这个大小。设置不好的话，常常会引起 java.lang.OutOfMemoryError: PermGen space java7，8的字符串常量池在堆中实现 字符串常量池被限制在整个应用的堆内存中，在运行时调用String.intern()增加字符串常量不会使永久代OOM了。 2.2.2、方法区的变化 java8的时候去除PermGen，将其中的方法区移到non-heap中的Metaspace Metaspace属于non-heap OOM异常 如果类元数据的空间占用达到MaxMetaspaceSize设置的值，将会触发对象和类加载器的垃圾回收。 java.lang.OutOfMemoryError: Metaspace space JVM从Metaspace在捕获一个一个内存分配失败后抛出。 2.3、Metaspace相关参数 -XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。 -XX:MaxMetaspaceSize，最大空间，默认是没有限制的。 -XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集 -XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集 2.4 、小结 将常量池从PermGen剥离到heap中，将元数据从PermGen剥离到元数据区，去除PermGen的好处如下： 将字符串常量池从PermGen分离出来，与类元数据分开，提升类元数据的独立性 将元数据从PermGen剥离出来到Metaspace，可以提升对元数据的管理同时提升GC效率。 在PermGen中元数据可能会随着每一次Full GC发生而进行移动。HotSpot虚拟机的每种类型的垃圾回收器都需要特殊处理PermGen中的元数据，分离出来以后可以简化Full GC以及对以后的并发隔离类元数据等方面进行优化。 为后续将HotSpot与JRockit合二为一做准备。 PermGen是HotSpot的实现特有的，JRockit并没有PermGen一说 3、工具准备 jvisualvm.exe javamelody druid arthas jmeter 4、初步分析 2.1、内存泄露 通过javamelody分析发现堆内存并未出现大的泄露问题 5、怀疑排查 3.1、druid连接池的问题 ​ 第一、本人对druid连接池做了拦截处理 ​ 第二、druid的默认监控数据是保存在内存中 3.2、spring-retry框架 spring-retry与springboot整合不当可能导致类重复加载 3.3、orika对象映射 多例使用orika的mapper对象可能导致堆外内存溢出 6、猜测验证 4.1、本地junit单元测试 4.2、jmeter压力测试 4.3、arthas在线观察内存使用情况 7、问题浮出水面 8、核心问题分析 orika是一个对象映射工具。由于这里没有用单例导致了内存的泄露 项目中大量使用了orika作为对象拷贝工具，但是都是在每个serviceImpl中去注册映射方式，其实整个项目中的方式也就5个，但是放到实现类中就会重复注册，而每次注册就会生成class信息，导致Metaspace占用空间增长。最终就出现了本项目中的问题。 解决办法 1、集中单例注册所有的orika的注册方式 2、优化jvm参数设置 9、后续 更多精彩，敬请关注， 程序员导航网 https://chenzhuofan.top Copyright© 浙ICP备19008730号 卓帆网 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-15 20:15:43 "},"linux/linux常用知识点.html":{"url":"linux/linux常用知识点.html","title":"linux常用知识","keywords":"","body":"linux常用知识网络抓包压缩解压解压war包linux常用知识 网络抓包 fconfig查看网卡 ip host tcpdump -i eth1 host hostname and port 80 -w /tmp/data.pcap 开源软件RawCap也可以抓到(下载地址:http://www.netresec.com/?page=RawCap).将抓到的包保存为pcap后缀,用wireshark打开,就可以继续分析了. win7以管理员身份运行，ctrl+c停止后pcap文件才有内容。今天刚好用，开始不会ctrl+c也是这种情况 压缩解压 1.压缩命令： 　　命令格式：tar -zcvf 压缩文件名.tar.gz 被压缩文件名 可先切换到当前目录下。压缩文件名和被压缩文件名都可加入路径。 2.解压缩命令： 　　命令格式：tar -zxvf 压缩文件名.tar.gz 　　解压缩后的文件只能放在当前的目录。 解压war包 jar -xvf project.war 需要说明的是可以指定解压到指定的目录，但是需要全路径，常用做法是把war包拷贝到当前目录后然后执行解压 Copyright© 浙ICP备19008730号 卓帆网 2019 all right reserved，powered by Gitbook该文件修订时间： 2017-07-27 15:09:35 "},"linux/从0到1打造自己专属内网穿透工具.html":{"url":"linux/从0到1打造自己专属内网穿透工具.html","title":"从0到1打造自己专属内网穿透工具","keywords":"","body":"Conn 1161从0到1打造自己专属内网穿透工具 1、什么人适合看这篇文章 正在使用teamview或者QQ等远程工具，但是经常掉线而烦恼的用户 有很多个人的站点，但是不想花费很多的资金去购买ecs服务器的用户 2、问题的由来 从笔者的自身的角度出发，以上的2个痛点都有 teamview个人版经常是掉线，商业版本价格不菲。但是远程办公的场景是不可避免的 个人电脑上搭建了一套漂亮的系统，想给不在一个局域网的朋友演示一番，对不起网络不通，难道必须要部署到一台具有公网ip的机器上才能达到目的，答案是No 随着自己的兴趣和业务的拓展，当初的一台ecs服务器已经出现了资源不足了，难道只能不上线了或者继续砸钱购买ecs,答案同样是No 所以本文是能给你带来便利和省money的福利文章 3、基础知识准备 3.1、什么是内网穿透 说的简单直白一点就是把处于内网的机器映射出去，让不在同一局域网的用户可以直接访问。感知如何访问是公网的ip一样 3.2、基本的原理 首先必须要有一台具有公网的ip的机器（暂且称为A）作为中心 内网机器(暂且称为B)通过socket与A进行socket进行通讯 用户直接访问A的地址，解析出对应的请求需要转发到B,所以消息的方式发送到B B收到消息，在本地执行请求的命令，然后到执行的结果以消息的方式回发给A A将结果返回给用户 实现的效果如同用户直接访问B一样 3.3、常规的实现方案 反向代理（如nginx,代理的机器需要和nginx在同一局域网内） 花生壳 nat123 ngrok frp 4、本文需要介绍的重点 本篇重点介绍的是其中的一款ngrok ngrok是一款开源的老牌的内网穿透工具，目前开源值1.7,2.0以上版本回归商业版，不过对于个人用户来说已经足够了，稳定好用，国内有不少的基于ngrok的二次开发收费工具。其实自己会搭建，何必花冤枉钱 5、ngrok搭建详细步骤 5.1、前期的必要准备 一台ecs 一个域名 域名需要本案，同时添加域名映射，ngrok.xx.com 需要添加三级域名映射 *.ngrok.xx.com (这个是重点，很多教程中都没提到这一点，走了不少弯路) 5.2、获取源码 源码的地址是https://github.com/chen-xing/ngrok-one-key-install 5.2.1、很多的教程的步骤是 搭建linux环境 安装 git go 环境 下载代码 生成证书 编译代码，根据平台分别生成不同版本的 服务端和客户端 启动服务端 配置config,启动客户端，连接客户端 5.2.2、难点 前置的环境步骤过多，而且很多都是国外，连接性不好 步骤繁琐，影响出现拦路虎而不不知所措 5.2.3、不一样的步骤 从git 上直接下载编译好的服务端和客端 下载地址：https://github.com/chen-xing/ngrok-one-key-install/tree/master/latest 注意匹配自己的机器的系统类型 5.3、服务端启动步骤 在服务端程序的同级目录下执行命令 ``` nohup ./ngrokd -domain=\"ngrok.xxx.com\" -httpAddr=\":8080\" -httpsAddr=\":8000\" -tunnelAddr=\":8001\" 命令参数解释 nohup 在操作系统后台运行次程序，防止控制台关闭，程序退出 domain 指定代理的域名，需要在域名服务上做好解析，客户端连接的时候需要对应上 httpAttr http请求的代理端口 httpsAttr https的请求的代理端口 tunnelAddr soket通讯的端口 出现以下的提示信息的时候说明是启动成功 [07:31:47 CST 2019/05/03] [INFO] (ngrok/log.(PrefixLogger).Info:83) [registry] [tun] No affinity cache specified [07:31:47 CST 2019/05/03] [INFO] (ngrok/log.Info:112) Listening for public http connections on [::]:8080 [07:31:47 CST 2019/05/03] [INFO] (ngrok/log.Info:112) Listening for public https connections on [::]:8000 [07:31:47 CST 2019/05/03] [INFO] (ngrok/log.Info:112) Listening for control and proxy connections on [::]:8001 [07:31:47 CST 2019/05/03] [INFO] (ngrok/log.(PrefixLogger).Info:83) [metrics] Reporting every 30 seconds [07:31:48 CST 2019/05/03] [INFO] (ngrok/log.(*PrefixLogger).Info:83) [pub:b078d6f] New connection from 58.101.43.167:9229 5.4、客户端的启动步骤 + 在客户端程序的同级目录下创建ngrok.cfg文件 server_addr: \"ngrok.xxx.com:8001\" trust_host_root_certs: false server_addr 指定服务端的通讯的端口，与服务端的tunnelAddr一致 trust_host_root_certs 关闭支持TLS加密协议的证书信任 + 执行客户端的启动命令 ngrok -config=ngrok.cfg -subdomain %clientid% %port% %clientid% 为需要映射出来的三级子域名，如aa %port% 为代理的本地的端口 如8080 ngrok (Ctrl+C to quit) Tunnel Status online Version 1.7/1.7 Forwarding http://aa.ngrok.xx.com:8080 -> 127.0.0.1:9080 Forwarding https://aa.ngrok.xx.com:8080 -> 127.0.0.1:9080 Web Interface 127.0.0.1:4040 Conn 1161 Avg Conn Time 5006.61ms 出现以下的页面的时候说明连接成功，可以使用 http://aa.ngrok.xx.com:8080 来访问你本地的站点 127.0.0.1:4040 则是本地流量回放的web页面 ![](https://img2018.cnblogs.com/blog/493641/201905/493641-20190506200918757-214970505.png) #### 5.5、远程桌面或远程服务代理 + 执行启动命令 ngrok -config=ngrok.cfg -proto=tcp %clientid% %port% 为代理的本地的端口 如22 执行成功就会把本地的22端口映射成公网地址，其他局域网的用不就可以用这个映射地址通过ssh工具来访问你的 机器 其他 3389 3306处理方式一样 + 客户端的命令说明 -log string Write log messages to this file. 'stdout' and 'none' have special meanings (default \"none\") -log-level string The level of messages to log. One of: DEBUG, INFO, WARNING, ERROR (default \"DEBUG\") -proto string The protocol of the traffic over the tunnel {'http', 'https', 'tcp'} (default: 'http+https') (default \"http+https\") -subdomain string Request a custom subdomain from the ngrok server. (HTTP only) Examples: ngrok 80 ngrok -subdomain=example 8080 ngrok -proto=tcp 22 ngrok -hostname=\"example.com\" -httpauth=\"user:password\" 10.0.0.1 Advanced usage: ngrok [OPTIONS] [command args] [...] Commands: ngrok start [tunnel] [...] Start tunnels by name from config file ngrok list List tunnel names from config file ngrok help Print help ngrok version Print ngrok version Examples: ngrok start www api blog pubsub ngrok -log=stdout -config=ngrok.yml start ssh ngrok version > 使用ngrok进行代理ssh的时候，服务端的端口是随机生成的，但是服务端处于安全性的考虑，能够开放的端口的有限的，那么如何固定ssh时候，服务端的端口 + 参考的配置 创建yml文件 ngrok.yml server_addr: \"ngrok.chenzhuofan.top:8001\" trust_host_root_certs: false tunnels: ssh: remote_port: 36826 proto: tcp: 3389 启动脚本 ngrok -log=stdout -config=ngrok.yml start ssh + 完整版的参考 server_addr: youdomain.com:4443 trust_host_root_certs: false inspect_addr: disabled auth_token: 用户ID password: \"认证ID\" tunnels: httptun: remote_port: 8443 subdomain: \"www.test\" proto: https: 192.168.1.1:80 nas: remote_port: 5000 subdomain: \"nas\" proto: https: 192.168.1.20:5000 mian: remote_port: 12322 proto: tcp: 192.168.1.1:22 ``` 6、后续 更多精彩，敬请关注， 程序员导航网 https://chenzhuofan.top Copyright© 浙ICP备19008730号 卓帆网 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-09 20:46:46 "},"工具/分享一款不错的typora主体.html":{"url":"工具/分享一款不错的typora主体.html","title":"分享一款不错的typora主体","keywords":"","body":"分享一款不错的typora主体 使用方法 在文件—>偏好设置中打开主题的文件夹 在同级目录下创建一个github.user.css文件 复制下文中的css 重启typora :root { --side-bar-bg-color: #d9d0bc; --control-text-color: #777; } @include-when-export url(https://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext); @font-face { font-family: 'Open Sans'; font-style: normal; font-weight: normal; src: local('Open Sans Regular'),url('./github/400.woff') format('woff') } @font-face { font-family: 'Open Sans'; font-style: italic; font-weight: normal; src: local('Open Sans Italic'),url('./github/400i.woff') format('woff') } @font-face { font-family: 'Open Sans'; font-style: normal; font-weight: bold; src: local('Open Sans Bold'),url('./github/700.woff') format('woff') } @font-face { font-family: 'Open Sans'; font-style: italic; font-weight: bold; src: local('Open Sans Bold Italic'),url('./github/700i.woff') format('woff') } html { font-size: 16px; } body { font-family: \"Open Sans\",\"Clear Sans\",\"Helvetica Neue\",Helvetica,Arial,sans-serif; /*color: rgb(51, 51, 51);*/ background-color: #d9d0bc; /*body bg color*/ line-height: 1.6; } #write{ max-width: 860px; margin-top: 30px; /*top*/ margin-bottom: 30px; padding: 100px 60px; /*top to title padding*/ border-radius: 5px; -o-box-shadow: 0 10px 10px #333333; -webkit-box-shadow: 0 10px 10px #333333; -moz-box-shadow: 0 10px 10px #333333; box-shadow: 0px 50px 100px #333333; } #write > ul:first-child, #write > ol:first-child{ margin-top: 30px; } body > *:first-child { margin-top: 0 !important; } body > *:last-child { margin-bottom: 0 !important; } a { color: #4183C4; } h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; } h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { /*background: url(\"../../images/modules/styleguide/para.png\") no-repeat 10px center;*/ text-decoration: none; } h1 tt, h1 code { font-size: inherit; } h2 tt, h2 code { font-size: inherit; } h3 tt, h3 code { font-size: inherit; } h4 tt, h4 code { font-size: inherit; } h5 tt, h5 code { font-size: inherit; } h6 tt, h6 code { font-size: inherit; } h1 { font-family: \"PT Serif\"; padding-bottom: .3em; font-size: 3em; line-height: 1.2; border-bottom: 1px solid #9b9692; text-align: center; } h2 { padding-bottom: .3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid #9b9692; } h3 { font-size: 1.5em; line-height: 1.43; } h4 { font-size: 1.25em; } h5 { font-size: 1em; } h6 { font-size: 1em; color: #777; } p, blockquote, ul, ol, dl, table{ margin: 0.8em 0; } li>ol, li>ul { margin: 0 0; } hr { height: 2px; padding: 0; margin: 16px 0; background-color: #e7e7e7; border: 0 none; overflow: hidden; box-sizing: content-box; } body > h2:first-child { margin-top: 0; padding-top: 0; } body > h1:first-child { margin-top: 0; padding-top: 0; } body > h1:first-child + h2 { margin-top: 0; padding-top: 0; } body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child { margin-top: 0; padding-top: 0; } a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 { margin-top: 0; padding-top: 0; } h1 p, h2 p, h3 p, h4 p, h5 p, h6 p { margin-top: 0; } li p.first { display: inline-block; } ul, ol { padding-left: 30px; } ul:first-child, ol:first-child { margin-top: 0; } ul:last-child, ol:last-child { margin-bottom: 0; } blockquote { border-left: 4px solid #dfe2e5; padding: 0 15px; color: #777777; } blockquote blockquote { padding-right: 0; } table { padding: 0; word-break: initial; } table tr { border-top: 1px solid #dfe2e5; margin: 0; padding: 0; background-color: rgba(93, 172, 129, 0.2); /*若竹*/ } table tr:nth-child(2n), thead { background-color: rgba(93, 172, 129, 0.2); /*set even row color*/ } tbody tr:nth-child(2n-1) { background-color: transparent !important; /*only odd row has color*/ } table tr th { font-weight: bold; border: 1px solid #dfe2e5; border-bottom: 0; text-align: left; margin: 0; padding: 6px 13px; } table tr td { border: 1px solid #dfe2e5; text-align: left; margin: 0; padding: 6px 13px; } table tr th:first-child, table tr td:first-child { margin-top: 0; } table tr th:last-child, table tr td:last-child { margin-bottom: 0; } .CodeMirror-lines { padding-left: 4px; } .code-tooltip { box-shadow: 0 1px 1px 0 rgba(0,28,36,.3); border-top: 1px solid #eef2f2; } code { background-color: #f3f4f4; padding: 0 4px 2px 4px; } .md-fences { margin-bottom: 15px; margin-top: 15px; padding: 0.2em 1em; padding-top: 8px; padding-bottom: 6px; } .md-task-list-item > input { margin-left: -1.3em; } @media screen and (min-width: 914px) { /*body { width: 854px; margin: 0 auto; }*/ } @media print { html { font-size: 13px; } table, pre { page-break-inside: avoid; } pre { word-wrap: break-word; } } #write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: #f7f7f7; border: 0; border-radius: 3px; color: #777777; margin-top: 0 !important; } .md-fences, code, tt { /*border: 1px solid #e7eaed;*/ background-color: rgb(197,137,88); /* code block inline BGcolor */ border-radius: 3px; padding: 0; padding: 2px 4px 0px 4px; font-size: 0.8em; font-family: menlo; /*color: #f9f2f4; /*code block inline font color*/ } .md-fences { background-color: #1e2128; /*code block bg color*/ color: #989fad; /*comma*/ } .cm-s-inner .cm-comment {color: #3f4450; /*comment color*/ } .cm-s-inner .cm-keyword {color: #c678dd; /*function*/ } .cm-s-inner .cm-def {color: #f9f2f4; } .cm-s-inner .cm-operator {color: #b75bd0; } /*return var*/ .cm-s-inner .cm-variable {color: #d19a66; /*window*/ } .cm-s-inner .cm-variable-2 { color: #e2b76a; } /*window jquery*/ .cm-s-inner .cm-string { color: #98c379; } /* string */ .cm-s-inner .cm-attribute { color: #FFCB6B; } .cm-s-inner .cm-property { color: #d19a66; } /*property*/ .cm-s-inner .cm-variable-3 { color: #DECB6B; } .cm-s-inner .cm-error {color: rgba(209, 154, 102, 1.0); background-color: #448867; } .cm-s-inner .cm-atom { color: #F77669; } /*null undefined*/ .cm-s-inner .cm-number { color: #F77669; } .cm-s-inner .cm-builtin { color: #DECB6B; } /*system built in command*/ .cm-s-inner .cm-tag { color: #80CBC4; } /*LaTeX command*/ .cm-s-inner .cm-meta { color: #80CBC4; } /*LaTeX command*/ .cm-s-inner .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; } .mathjax-block>.code-tooltip { bottom: .375rem; } .md-mathjax-midline { background: ; } #write>h3.md-focus:before{ left: -1.5625rem; top: .375rem; } #write>h4.md-focus:before{ left: -1.5625rem; top: .285714286rem; } #write>h5.md-focus:before{ left: -1.5625rem; top: .285714286rem; } #write>h6.md-focus:before{ left: -1.5625rem; top: .285714286rem; } .md-image>.md-meta { /*border: 1px solid #ddd;*/ border-radius: 3px; padding: 2px 0px 0px 4px; font-size: 0.9em; color: inherit; } .md-tag { color: #a7a7a7; opacity: 1; } .md-toc { margin-top:20px; padding-bottom:20px; } .sidebar-tabs { border-bottom: none; } #typora-quick-open { border: 1px solid #ddd; background-color: #f8f8f8; } #typora-quick-open-item { background-color: #FAFAFA; border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee; border-style: solid; border-width: 1px; } /** focus mode */ .on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); } header, .context-menu, .megamenu-content, footer{ font-family: \"Segoe UI\", \"Arial\", sans-serif; } .file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state{ visibility: visible; } .mac-seamless-mode #typora-sidebar { background-color: #fafafa; background-color: var(--side-bar-bg-color); } .md-lang { color: #b4654d; } .html-for-mac .context-menu { --item-hover-bg-color: #E6F0FE; } Copyright© 浙ICP备19008730号 卓帆网 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-06 20:27:46 "},"架构/数据库表结构自动修复和表数据同步原理分析.html":{"url":"架构/数据库表结构自动修复和表数据同步原理分析.html","title":"大家是否有这样的体验:","keywords":"","body":"大家是否有这样的体验: 1、项目在本地多人开发，多次进行数据库修改操作，但忘记记录操作脚本了，现在将要升级线上程序，束手无策 2、线上执行数据库脚本较多，其中某一条出现了问题，然后就不知道了从哪里开始了，或者漏掉了其中一两条，难道要靠苦力慢慢去核对？ 3、如何将备用的数据库的表结构自动修正为主库的结构，如何自动同步默认的基础表数据 所以设计一个自动检测数据库差异性并自动修复的工具显得尤为重要，解放人力，保障效率 设计思路: 1、设计一种数据结构：能够把标准库的表结构和基础数据输出 2、用这个导出的数据模版去验证待验证的数据库 3、检测工具发现差异，生成修复的sql语句自动执行或生成sql预览，审核后在执行 4、完成数据库的一致性 数据导出结构: objects：包含所有的数据对象 表、视图。序列 object：具体的数据库对象 type:数据对象的分类标识包含table(表)、view(视图)、sequence（序列） name:对象名称 time：创建时间 comment:备注 field：表中的字段属性 name:字段名 type:字段数据类型 comment:备注 isKey：是否主键 其中视图中的文本是视图的创建语句 接下来的关键工作则是怎么把数据库中的数据和表生成这种xml的数据载体: 其实这个主要就是利用数据的系统表分组就行遍历输出，没有什么特殊的 这里提供2个下载地址: 1、核心的操作类: http://download.csdn.net/detail/cx308679291/5989153 完整的工具源代码:http://download.csdn.net/detail/cx308679291/9914031 有什么疑问可以大家一起讨论 Copyright© 浙ICP备19008730号 卓帆网 2019 all right reserved，powered by Gitbook该文件修订时间： 2017-07-28 16:23:28 "}}